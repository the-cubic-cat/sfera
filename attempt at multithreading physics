std::vector<BallPair> result;
    auto& balls = m_world.getBallsModifiable();

    std::mutex resultMutex{};

    std::vector<std::thread> threads_colSearch{};

    int i{0};

    for (auto& ba : balls){
    threads_colSearch.push_back(std::thread(
    [&]()
    {
        for (auto& bb : balls)
        {
            Debug::out("thread " + std::to_string(i));
            i++;
            if (bb == ba) { continue; }

            Eigen::Vector2d aPos{ba.getPositionAtTime(m_simulationTime)};
            double aRad{ba.getRadius()};

            Eigen::Vector2d bPos{bb.getPositionAtTime(m_simulationTime)};
            double bRad{bb.getRadius()};

            double radSum{bRad + aRad + collisionErrorMarginHeuristic};

            // preliminary filter to reduce amount of math
            if (abs(aPos.x() - bPos.x()) > radSum 
             || abs(aPos.y() - bPos.y()) > radSum) { continue; }

            // not knowing linear algebra, the fact that norm() returns the absolute
            // value of a vector and not the normalized form of a vector severely
            // fucked me over
            double distanceSquare{((aPos - bPos).squaredNorm())};
            double collisionDistance{aRad + bRad};

            if (getTouching) 
                { collisionDistance += std::max(bRad, aRad) * m_collisionErrMargin; }

            double collisionDistanceSquare{collisionDistance * collisionDistance};

            if (distanceSquare <= collisionDistanceSquare)
            {
                resultMutex.lock();
                result.push_back({ba, bb});
                resultMutex.unlock();
            }
    }}));}

    for (auto& t : threads_colSearch)
    {
        t.join();
    }

    return result;